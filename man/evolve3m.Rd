% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/terga2.lib.R
\name{evolve3m}
\alias{evolve3m}
\title{Evolve a Population with Advanced Mating and Mutation}
\usage{
evolve3m(X, y, clf, pop, featEval)
}
\arguments{
\item{X}{A matrix or data frame of feature values, where each row represents
a feature and each column represents a sample.}

\item{y}{A response vector or target variable for supervised learning. The
length of \code{y} should match the number of columns in \code{X}.}

\item{clf}{A classifier object containing parameters for evolution, including
options for mutation size, parallel processing, and debugging.}

\item{pop}{A list representing the population, where each individual has
attributes like `mate` and `toBeMutated`.}

\item{featEval}{A vector or list containing feature evaluation metrics, used
to guide mutation.}
}
\value{
The evolved population list, including new offspring and mutated
  individuals.
}
\description{
This function performs one generation of evolution on a population, including
advanced mating and mutation, with optional parallel processing. It returns
the evolved population after these operations.
}
\details{
The `evolve3m` function performs an evolutionary cycle on the
population with the following steps:

1. **Population Evaluation**: Each individual in the population is evaluated
if not already done, and `mate` and `toBeMutated` attributes are initialized.
2. **Tagging for Selection and Mating**: Individuals are tagged based on
selection criteria from `clf`. 3. **Crossover and Mutation**: For individuals
with mates, offspring are generated using the `crosser` function. If an
individual is marked for mutation, the `mutator` function is applied.

The function supports parallel processing, where crossover and mutation steps
are performed concurrently if `clf$params$parallel.local` is `TRUE`. After
crossover and mutation, children and mutated individuals are combined into a
new population. If `debug` mode is enabled, messages track the evolution
process.
}
\examples{
\dontrun{
X <- matrix(rnorm(100), nrow = 10) # Random features
y <- sample(c(0, 1), 10, replace = TRUE) # Random binary response
clf <- list(params = list(
  mutate_size = 10, parallel.local = FALSE, debug = TRUE
))
pop <- list(
  list(fit_ = NA, indices_ = 1:5, selected = FALSE, toBeMutated = FALSE, mate = NULL),
  list(fit_ = NA, indices_ = 6:10, selected = FALSE, toBeMutated = FALSE, mate = NULL)
)
featEval <- runif(10)
evolved_pop <- evolve3m(X, y, clf, pop, featEval)
}

}
