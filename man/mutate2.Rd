% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/terga2.lib.R
\name{mutate2}
\alias{mutate2}
\title{Apply Mutation to a Selected Subset of the Population}
\usage{
mutate2(X, y, clf, pop, selection, featEval)
}
\arguments{
\item{X}{A matrix or data frame of feature values, where each row represents
a feature and each column represents a sample.}

\item{y}{A response vector or target variable for supervised learning. The
length of \code{y} should match the number of columns in \code{X}.}

\item{clf}{A classifier object containing parameters for mutation, including
`size_world` (total number of genes) and `parallel.local` (to enable
parallel computation).}

\item{pop}{A list representing the population, where each individual has
attributes relevant to mutation.}

\item{selection}{A vector of indices representing the individuals in `pop`
that should be mutated.}

\item{featEval}{A numeric vector of feature evaluation scores, which will be
updated to reflect the mutation's effect on feature importance.}
}
\value{
A list representing the mutated population, with the individuals in
  `selection` modified according to mutation operations.
}
\description{
This function performs mutation on a selected subset of individuals in a
population, using feature evaluations to guide mutation decisions. It returns
the mutated population.
}
\details{
The `mutate2` function first ranks features using `rankFeatures`,
updating `featEval` based on model fitness in the population. It then
iterates over the selected individuals (`selection`), applying mutation to
each. If parallel processing is enabled (`clf$params$parallel.local`),
mutations are performed concurrently.

The mutation process uses the classifier's `mutator` function to alter gene
indices or coefficients in each selected individual based on feature
evaluation probabilities.
}
\examples{
\dontrun{
X <- matrix(rnorm(100), nrow = 10) # Random features
y <- sample(c(0, 1), 10, replace = TRUE) # Random binary response
clf <- list(params = list(size_world = 10, parallel.local = FALSE),
            functions = list(mutator = mutator_v1))
pop <- list(
  list(indices_ = c(1, 3, 5), fit_ = 0.8),
  list(indices_ = c(2, 4, 6), fit_ = 0.7)
)
selection <- 1:2
featEval <- rep(0, 10)
mutated_pop <- mutate2(X, y, clf, pop, selection, featEval)
}

}
